from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from . import database
from . import settings_service

def get_weekly_stats(db: Session):
    """Calculate total minutes and units for Monday - Friday of the current week."""
    now = datetime.now()
    # Find Monday of this week
    monday = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)
    
    # Initialize Mon-Fri array
    stats = [
        {"day": "Mon", "minutes": 0, "units": 0, "date": (monday + timedelta(days=0)).strftime("%Y-%m-%d")},
        {"day": "Tue", "minutes": 0, "units": 0, "date": (monday + timedelta(days=1)).strftime("%Y-%m-%d")},
        {"day": "Wed", "minutes": 0, "units": 0, "date": (monday + timedelta(days=2)).strftime("%Y-%m-%d")},
        {"day": "Thu", "minutes": 0, "units": 0, "date": (monday + timedelta(days=3)).strftime("%Y-%m-%d")},
        {"day": "Fri", "minutes": 0, "units": 0, "date": (monday + timedelta(days=4)).strftime("%Y-%m-%d")},
    ]
    
    friday_end = monday + timedelta(days=4, hours=23, minutes=59, seconds=59)
    
    # Get logs from this Mon to Fri
    logs = db.query(database.TimeLog).filter(
        database.TimeLog.log_date >= monday,
        database.TimeLog.log_date <= friday_end
    ).all()
    
    for log in logs:
        # 0 = Mon, 4 = Fri
        day_idx = log.log_date.weekday()
        if 0 <= day_idx <= 4:
            stats[day_idx]["minutes"] += log.duration_minutes
            stats[day_idx]["units"] += log.units
            
    return stats

def get_dynamic_reminders(db: Session):
    """Generate dynamic sticky notes for idle, new, and urgent matters."""
    import json
    matters = db.query(database.Matter).filter(database.Matter.is_closed == False).all()
    now = datetime.now()
    reminders = []
    
    overrides = settings_service.get_sticky_overrides()
    
    for m in matters:
        if m.status_flag == "green":
            continue
            
        # Urgent Matters (Red flag)
        if m.status_flag == "red":
            note_id = f"dynamic_urgent_{m.id}"
            ov = overrides.get(note_id, {})
            if isinstance(ov, str): ov = {"text": ov}
            
            reminders.append({
                "id": note_id,
                "type": "urgent",
                "title": ov.get("title", "Urgent Matter"),
                "text": ov.get("text", f"{m.name} requires immediate attention."),
                "matter_id": m.id,
                "color": ov.get("color", "red")
            })
            continue # Prioritize urgent over idle/new
            
        logs = m.time_logs
        
        # New Scanned Matters (0 logs, has source_email_id)
        if not logs and m.source_email_id:
            ext_id_str = f" [{m.external_id}]" if m.external_id else ""
            note_id = f"dynamic_new_{m.id}"
            ov = overrides.get(note_id, {})
            if isinstance(ov, str): ov = {"text": ov}
            
            reminders.append({
                "id": note_id,
                "type": "new",
                "title": ov.get("title", f"New Scan{ext_id_str}"),
                "text": ov.get("text", f"Evaluate scanned matter: {m.name}"),
                "matter_id": m.id,
                "color": ov.get("color", "green")
            })
            continue
            
        # Idle Matters (Yellow flag, no logs in > 3 days)
        if m.status_flag == "yellow" and logs:
            latest_log_date = max(log.log_date for log in logs)
            if (now - latest_log_date).days > 3:
                note_id = f"dynamic_idle_{m.id}"
                ov = overrides.get(note_id, {})
                if isinstance(ov, str): ov = {"text": ov}
                
                reminders.append({
                    "id": note_id,
                    "type": "idle",
                    "title": ov.get("title", "Idle Matter"),
                    "text": ov.get("text", f"No time logged for {m.name} in over 3 days."),
                    "matter_id": m.id,
                    "color": ov.get("color", "yellow")
                })
                
    return reminders

def get_all_sticky_notes(db: Session):
    """Combine dynamic reminders and manual user sticky notes."""
    dynamic = get_dynamic_reminders(db)
    manual = settings_service.get_sticky_notes()
    
    # manual notes should have an ID generated by frontend, color, title, and text
    return {
        "dynamic": dynamic,
        "manual": manual
    }
    
def add_manual_note(note: dict):
    notes = settings_service.get_sticky_notes()
    notes.append(note)
    settings_service.save_sticky_notes(notes)
    return note
    
def delete_manual_note(note_id: str):
    notes = settings_service.get_sticky_notes()
    filtered = [n for n in notes if n.get("id") != note_id]
    settings_service.save_sticky_notes(filtered)

def update_sticky_note(note_id: str, updates: dict):
    if note_id.startswith("dynamic_"):
        overrides = settings_service.get_sticky_overrides()
            
        if note_id not in overrides or isinstance(overrides.get(note_id), str):
            old_val = overrides.get(note_id, "")
            overrides[note_id] = {"text": old_val} if old_val else {}
            
        if "text" in updates:
            overrides[note_id]["text"] = updates["text"]
        if "title" in updates:
            overrides[note_id]["title"] = updates["title"]
        if "color" in updates:
            overrides[note_id]["color"] = updates["color"]
            
        settings_service.save_sticky_overrides(overrides)
    else:
        notes = settings_service.get_sticky_notes()
        for n in notes:
            if n.get("id") == note_id:
                if "text" in updates:
                    n["text"] = updates["text"]
                if "title" in updates:
                    n["title"] = updates["title"]
                if "color" in updates:
                    n["color"] = updates["color"]
        settings_service.save_sticky_notes(notes)
